
#![no_std]

use klever_sc::imports::*;

/// DGKO/USDT DEX Swap Contract
/// 
/// This contract implements an Automated Market Maker (AMM) for swapping
/// DGKO and USDT tokens using the constant product formula (x * y = k).
/// 
/// Key Features:
/// - Maintains liquidity pools for DGKO and USDT
/// - Executes token swaps with automatic pricing
/// - Collects platform fees in KLV
/// - Owner-controlled liquidity management
#[klever_sc::contract]
pub trait DigikoSwapContract {
    
    // ========== INITIALIZATION ==========
    
    /// Initialize the contract with owner and initial liquidity
    /// 
    /// @param dgko_reserve - Initial DGKO tokens (with 4 decimals)
    /// @param usdt_reserve - Initial USDT tokens (with 6 decimals)
    #[init]
    fn init(&self, dgko_reserve: BigUint, usdt_reserve: BigUint) {
        // Set contract owner (deployer)
        let caller = self.blockchain().get_caller();
        self.owner().set(&caller);
        
        // Initialize liquidity pools
        self.dgko_reserve().set(&dgko_reserve);
        self.usdt_reserve().set(&usdt_reserve);
        
        // Initialize fee collector to owner
        self.fee_collector().set(&caller);
    }

    #[upgrade]
    fn upgrade(&self) {}

    // ========== SWAP ENDPOINTS ==========
    
    /// Swap DGKO for USDT
    /// User sends DGKO, receives USDT back
    /// 
    /// @payment - DGKO tokens sent by user
    #[payable("*")]
    #[endpoint(swapDgkoToUsdt)]
    fn swap_dgko_to_usdt(&self) {
        // Get payment info
        let payment = self.call_value().single_kda();
        let dgko_in = payment.amount;
        
        require!(dgko_in > 0u64, "Must send DGKO tokens");
        
        // Verify it's DGKO token
        let dgko_token_id = TokenIdentifier::from("DGKO-CXVJ");
        require!(payment.token_identifier == dgko_token_id, "Must send DGKO tokens");
        
        // Calculate output using AMM formula
        let dgko_reserve_before = self.dgko_reserve().get();
        let usdt_reserve_before = self.usdt_reserve().get();
        
        let usdt_out = self.calculate_output_amount(&dgko_in, &dgko_reserve_before, &usdt_reserve_before);
        
        require!(usdt_out > 0u64, "Insufficient output amount");
        require!(usdt_out <= &usdt_reserve_before / 2u64, "Exceeds max swap size (50% of liquidity)");
        
        // Update reserves
        let dgko_reserve_after = &dgko_reserve_before + &dgko_in;
        let usdt_reserve_after = &usdt_reserve_before - &usdt_out;
        
        self.dgko_reserve().set(&dgko_reserve_after);
        self.usdt_reserve().set(&usdt_reserve_after);
        
        // Send USDT to user
        let caller = self.blockchain().get_caller();
        let usdt_token_id = TokenIdentifier::from("USDT");
        self.send().direct_kda(&caller, &usdt_token_id, 0, &usdt_out);
        
        // Emit swap event
        self.swap_event(&caller, &dgko_token_id, &dgko_in, &usdt_token_id, &usdt_out);
    }
    
    /// Swap USDT for DGKO
    /// User sends USDT, receives DGKO back
    /// 
    /// @payment - USDT tokens sent by user
    #[payable("*")]
    #[endpoint(swapUsdtToDgko)]
    fn swap_usdt_to_dgko(&self) {
        // Get payment info
        let payment = self.call_value().single_kda();
        let usdt_in = payment.amount;
        
        require!(usdt_in > 0u64, "Must send USDT tokens");
        
        // Verify it's USDT token
        let usdt_token_id = TokenIdentifier::from("USDT");
        require!(payment.token_identifier == usdt_token_id, "Must send USDT tokens");
        
        // Calculate output using AMM formula
        let usdt_reserve_before = self.usdt_reserve().get();
        let dgko_reserve_before = self.dgko_reserve().get();
        
        let dgko_out = self.calculate_output_amount(&usdt_in, &usdt_reserve_before, &dgko_reserve_before);
        
        require!(dgko_out > 0u64, "Insufficient output amount");
        require!(dgko_out <= &dgko_reserve_before / 2u64, "Exceeds max swap size (50% of liquidity)");
        
        // Update reserves
        let usdt_reserve_after = &usdt_reserve_before + &usdt_in;
        let dgko_reserve_after = &dgko_reserve_before - &dgko_out;
        
        self.usdt_reserve().set(&usdt_reserve_after);
        self.dgko_reserve().set(&dgko_reserve_after);
        
        // Send DGKO to user
        let caller = self.blockchain().get_caller();
        let dgko_token_id = TokenIdentifier::from("DGKO-CXVJ");
        self.send().direct_kda(&caller, &dgko_token_id, 0, &dgko_out);
        
        // Emit swap event
        self.swap_event(&caller, &usdt_token_id, &usdt_in, &dgko_token_id, &dgko_out);
    }

    // ========== OWNER FUNCTIONS ==========
    
    /// Add liquidity to the pool (owner only)
    #[only_owner]
    #[payable("*")]
    #[endpoint(addLiquidity)]
    fn add_liquidity(&self) {
        let payments = self.call_value().all_kda_transfers();
        
        for payment in payments.iter() {
            let token_id = payment.token_identifier;
            let amount = payment.amount;
            
            if token_id == TokenIdentifier::from("DGKO-CXVJ") {
                let current = self.dgko_reserve().get();
                self.dgko_reserve().set(&(&current + &amount));
            } else if token_id == TokenIdentifier::from("USDT") {
                let current = self.usdt_reserve().get();
                self.usdt_reserve().set(&(&current + &amount));
            }
        }
    }
    
    /// Remove liquidity from the pool (owner only)
    #[only_owner]
    #[endpoint(removeLiquidity)]
    fn remove_liquidity(&self, dgko_amount: BigUint, usdt_amount: BigUint) {
        let owner = self.owner().get();
        
        // Withdraw DGKO
        if dgko_amount > 0u64 {
            let dgko_reserve = self.dgko_reserve().get();
            require!(dgko_amount <= dgko_reserve, "Insufficient DGKO in pool");
            
            let dgko_token_id = TokenIdentifier::from("DGKO-CXVJ");
            self.send().direct_kda(&owner, &dgko_token_id, 0, &dgko_amount);
            self.dgko_reserve().set(&(&dgko_reserve - &dgko_amount));
        }
        
        // Withdraw USDT
        if usdt_amount > 0u64 {
            let usdt_reserve = self.usdt_reserve().get();
            require!(usdt_amount <= usdt_reserve, "Insufficient USDT in pool");
            
            let usdt_token_id = TokenIdentifier::from("USDT");
            self.send().direct_kda(&owner, &usdt_token_id, 0, &usdt_amount);
            self.usdt_reserve().set(&(&usdt_reserve - &usdt_amount));
        }
    }
    
    /// Update fee collector address (owner only)
    #[only_owner]
    #[endpoint(setFeeCollector)]
    fn set_fee_collector(&self, new_collector: ManagedAddress) {
        self.fee_collector().set(&new_collector);
    }

    // ========== VIEW FUNCTIONS ==========
    
    /// Get current DGKO reserve
    #[view(getDgkoReserve)]
    fn get_dgko_reserve(&self) -> BigUint {
        self.dgko_reserve().get()
    }
    
    /// Get current USDT reserve
    #[view(getUsdtReserve)]
    fn get_usdt_reserve(&self) -> BigUint {
        self.usdt_reserve().get()
    }
    
    /// Get current price (USDT per DGKO)
    #[view(getPrice)]
    fn get_price(&self) -> BigUint {
        let dgko_reserve = self.dgko_reserve().get();
        let usdt_reserve = self.usdt_reserve().get();
        
        // Price = USDT_reserve / DGKO_reserve
        // Multiply by precision to get decimal price
        &usdt_reserve * 1_000_000u64 / &dgko_reserve
    }
    
    /// Calculate output amount for a given input
    #[view(calculateOutput)]
    fn calculate_output(&self, input_amount: BigUint, is_dgko_to_usdt: bool) -> BigUint {
        if is_dgko_to_usdt {
            let dgko_reserve = self.dgko_reserve().get();
            let usdt_reserve = self.usdt_reserve().get();
            self.calculate_output_amount(&input_amount, &dgko_reserve, &usdt_reserve)
        } else {
            let usdt_reserve = self.usdt_reserve().get();
            let dgko_reserve = self.dgko_reserve().get();
            self.calculate_output_amount(&input_amount, &usdt_reserve, &dgko_reserve)
        }
    }

    // ========== INTERNAL FUNCTIONS ==========
    
    /// Calculate output amount using constant product formula
    /// Output = (Input * Output_Reserve) / (Input_Reserve + Input)
    fn calculate_output_amount(
        &self,
        input_amount: &BigUint,
        input_reserve: &BigUint,
        output_reserve: &BigUint,
    ) -> BigUint {
        let numerator = input_amount * output_reserve;
        let denominator = input_reserve + input_amount;
        numerator / denominator
    }

    // ========== EVENTS ==========
    
    #[event("swap")]
    fn swap_event(
        &self,
        #[indexed] user: &ManagedAddress,
        #[indexed] token_in: &TokenIdentifier,
        #[indexed] token_out: &TokenIdentifier,
        #[indexed] amount_in: &BigUint,
        #[indexed] amount_out: &BigUint,
    );

    // ========== STORAGE ==========
    
    #[storage_mapper("owner")]
    fn owner(&self) -> SingleValueMapper<ManagedAddress>;
    
    #[storage_mapper("dgkoReserve")]
    fn dgko_reserve(&self) -> SingleValueMapper<BigUint>;
    
    #[storage_mapper("usdtReserve")]
    fn usdt_reserve(&self) -> SingleValueMapper<BigUint>;
    
    #[storage_mapper("feeCollector")]
    fn fee_collector(&self) -> SingleValueMapper<ManagedAddress>;
}
